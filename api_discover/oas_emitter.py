"""Generate OpenAPI 3.0.3 spec from discovered endpoints."""

from __future__ import annotations

import json
import re
from collections import OrderedDict
from typing import List, Optional

import yaml

from .models import Endpoint, Parameter
from .ruby_helpers import camelize


def emit_openapi(endpoints: List[Endpoint], repo_name: str = "rails-app",
                 include_conditional: bool = True,
                 exclude_engines: bool = False) -> dict:
    """Convert endpoints to an OpenAPI 3.0.3 spec dict."""
    spec = OrderedDict()
    spec["openapi"] = "3.0.3"
    spec["info"] = OrderedDict([
        ("title", f"API discovered from {repo_name}"),
        ("version", "discovered"),
        ("description", "Auto-generated by api-discover. Review and refine."),
    ])
    spec["paths"] = OrderedDict()

    filtered = _filter_endpoints(endpoints, include_conditional, exclude_engines)

    # Group by path
    by_path = OrderedDict()
    for ep in filtered:
        by_path.setdefault(ep.path, []).append(ep)

    for path, eps in sorted(by_path.items()):
        oas_path = _to_oas_path(path)
        path_item = OrderedDict()

        for ep in eps:
            method = ep.method.lower()
            if method == "*":
                # Mounted engine — use x-mounted-engine extension
                path_item["x-mounted-engine"] = ep.engine_name or "unknown"
                continue

            operation = _build_operation(ep)
            path_item[method] = operation

        if path_item:
            spec["paths"][oas_path] = path_item

    return spec


def emit_yaml(spec: dict) -> str:
    """Serialize OpenAPI spec to YAML."""
    return yaml.dump(_to_plain_dict(spec), default_flow_style=False,
                     sort_keys=False, allow_unicode=True)


def _to_plain_dict(obj):
    """Recursively convert OrderedDicts to plain dicts for YAML serialization."""
    if isinstance(obj, dict):
        return {k: _to_plain_dict(v) for k, v in obj.items()}
    if isinstance(obj, (list, tuple)):
        return [_to_plain_dict(item) for item in obj]
    return obj


def emit_json(spec: dict) -> str:
    """Serialize OpenAPI spec to JSON."""
    return json.dumps(spec, indent=2, ensure_ascii=False)


def _filter_endpoints(endpoints: List[Endpoint], include_conditional: bool,
                      exclude_engines: bool) -> List[Endpoint]:
    """Filter endpoints based on options."""
    result = []
    for ep in endpoints:
        if exclude_engines and ep.is_mounted_engine:
            continue
        if not include_conditional and ep.condition:
            continue
        result.append(ep)
    return result


def _to_oas_path(path: str) -> str:
    """Convert Rails :param style to OpenAPI {param} style."""
    return re.sub(r":(\w+)", r"{\1}", path)


def _build_operation(ep: Endpoint) -> OrderedDict:
    """Build an OpenAPI operation object for an endpoint."""
    op = OrderedDict()

    # operationId
    op_id = _make_operation_id(ep)
    op["operationId"] = op_id

    # Tags — group by controller
    if ep.controller:
        op["tags"] = [ep.controller]

    # Summary
    if ep.is_dynamic:
        op["summary"] = f"[DYNAMIC] {ep.action}"
    elif ep.is_redirect:
        op["summary"] = f"[REDIRECT] {ep.action}"
    elif ep.condition:
        op["summary"] = f"[CONDITIONAL] {ep.action}"
    else:
        op["summary"] = ep.action

    # Parameters (path params)
    params = []
    for pp in ep.path_params:
        param_type = "integer" if pp == "id" else "string"
        params.append(OrderedDict([
            ("name", pp),
            ("in", "path"),
            ("required", True),
            ("schema", OrderedDict([("type", param_type)])),
        ]))

    if params:
        op["parameters"] = params

    # Request body (from strong params)
    if ep.body_params and ep.method in ("POST", "PUT", "PATCH"):
        op["requestBody"] = _build_request_body(ep.body_params)

    # Responses (minimal)
    op["responses"] = OrderedDict([
        ("200", OrderedDict([("description", "Success")])),
    ])

    # Extensions
    if ep.controller:
        op["x-controller"] = camelize(ep.controller) + "Controller"
    op["x-action"] = ep.action

    if ep.has_auth is True:
        op["x-auth-status"] = "authenticated"
        op["x-auth-filters"] = ep.auth_filters
    elif ep.has_auth is False:
        op["x-auth-status"] = "UNPROTECTED"
    else:
        op["x-auth-status"] = "unknown"

    if ep.source_file:
        source = ep.source_file
        if ep.source_line:
            source = f"{source}:{ep.source_line}"
        op["x-source"] = source

    if ep.condition:
        op["x-condition"] = ep.condition

    if ep.is_dynamic:
        op["x-warning"] = "Route uses dynamic evaluation; path may be incomplete"

    if ep.is_mounted_engine:
        op["x-mounted-engine"] = ep.engine_name

    return op


def _build_request_body(params: List[Parameter]) -> OrderedDict:
    """Build an OpenAPI requestBody from strong params."""
    properties = OrderedDict()
    required = []

    for p in params:
        properties[p.name] = OrderedDict([("type", p.param_type)])
        if p.required:
            required.append(p.name)

    schema = OrderedDict([
        ("type", "object"),
        ("properties", properties),
    ])
    if required:
        schema["required"] = required

    return OrderedDict([
        ("content", OrderedDict([
            ("application/json", OrderedDict([
                ("schema", schema),
            ])),
        ])),
    ])


def _make_operation_id(ep: Endpoint) -> str:
    """Generate an operationId from controller and action."""
    parts = []
    if ep.controller:
        parts.append(ep.controller.replace("/", "_"))
    parts.append(ep.action)
    return "_".join(parts)
